{"config":{"title":"Aquarium PCR Models","description":"Libraries to model PCR composition and program, and help with master mixes","copyright":"University of Washington","version":"0.1.1","authors":[{"name":"Devin Strickland","affiliation":"University of Washington"}],"maintainer":{"name":"Devin Strickland","email":"strcklnd@uw.edu"},"acknowledgements":[{"name":"Ben Keller","affilation":"","affiliation":"University of Washington"}],"github":{"user":"dvnstrcklnd","repo":"aq-pcr-models"},"keywords":null,"aquadoc_version":"1.0.2","aquarium_version":"\u003c%= Bioturk::Application.config.aquarium_version %\u003e"},"components":[{"library":{"name":"MasterMixHelper","category":"PCR Libs","code_source":"needs \"Standard Libs/Units\"\nneeds \"Standard Libs/CommonInputOutputNames\"\n\n# Contains methods for assembling and dispensing master mixes\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nmodule MasterMixHelper\n\n    include CommonInputOutputNames\n    include Units\n\n    # TODO: Get this out of here.\n    TEST = \"TEST\"\n\n    # Group operations by multiple inputs\n    # @todo Make the grouped Operations be OperationLists\n    #\n    # @param input_names [Array\u003cString\u003e] names of inputs to be included in grouping\n    # @param ops [OperationList, Array\u003cOperation\u003e] operations to be grouped\n    # @return [Array(Array\u003cString\u003e, Hash{Array\u003cFixNum\u003e =\u003e Array\u003cOperation\u003e})] the input IDs\n    #   with singletons eliminated, followed by the grouped operations\n    def group_ops_by_inputs(input_names:, ops:)\n        input_names = eliminate_singletons(input_names: input_names, ops: ops)\n        grouped_ops = ops.group_by { |op| input_item_id_array(input_names: input_names, op: op) }\n        [input_names, grouped_ops]\n    end\n\n    # Remove input names from the list where each operation is a different input item\n    #\n    # @param input_names [Array\u003cString\u003e] input names to be tested and, if appropriate, eliminated\n    # @param ops [OperationList, Array\u003cOperation\u003e] operations\n    # @return [Array\u003cString\u003e] the input names with singletons eliminated\n    def eliminate_singletons(input_names:, ops:)\n        input_names.reject { |n| singletons?(input_name: n, ops: ops) }\n    end\n\n    # Tests whether each operation has a different item for a given input name and\n    #   returns true if each is different\n    #\n    # @param input_name [String] input name to be tested\n    # @param ops [OperationList, Array\u003cOperation\u003e] operations\n    # @return [Boolean]\n    def singletons?(input_name:, ops:)\n        ops.map { |op| item_id(input_name: input_name, op: op) }.uniq.length == ops.length\n    end\n\n    # Gets the ID for the Item or Part specified by a given input name\n    #\n    # @param input_name [String] input name to be tested\n    # @param op [Operation]\n    # @return [FixNum] the Item or Part ID\n    def item_id(input_name:, op:)\n        fv = op.input(input_name)\n        fv.part.try(:id) || fv.item.id\n    end\n\n    # Maps Item IDs for a given list of input names and a given operation\n    #\n    # @param input_names [Array\u003cString\u003e] input names to be mapped\n    # @param op [Operation]\n    # @return [Array\u003cFixNum\u003e]\n    def input_item_id_array(input_names:, op:)\n        input_names.map { |n| op.input(n).child_item_id }\n    end\n\n    # Makes master mix(es) for a set of operations\n    # Assumes that all operations have the same PCR program\n    #\n    # @param grouped_ops [Hash{Array\u003cFixNum\u003e =\u003e Array\u003cOperation\u003e}] hash of operations\n    #   grouped by input IDs\n    # @param input_names [Array\u003cString\u003e] input names corresponding to grouped_ops keys\n    # @param composition [PCRComposition]\n    # @param mult [Float] Amount to multiply each component volume by to account for\n    #   pipetting error\n    # @return [Hash{String =\u003e Array\u003cOperation\u003e}] hash of operations grouped by tube labels\n    def make_master_mixes(grouped_ops:, input_names:, composition:, mult: 1.0)\n        ops_by_master_mix = {}\n\n        grouped_ops.each_with_index do |(inputs, ops), i|\n            mm_tube_label = \"MM#{i+1}\"\n            this_mult = mult * ops.length\n\n            master_mix_table = master_mix_table(\n                inputs: inputs,\n                input_names: input_names,\n                composition: composition,\n                mult: this_mult\n            )\n\n            show do\n                title \"Make Master Mix #{mm_tube_label}\"\n\n                check \"Get a 1.5mL tube and label it \u003cb\u003e#{mm_tube_label}\u003c/b\u003e.\"\n                note \"Add reaction components as indicated:\"\n                table master_mix_table\n            end\n\n            ops_by_master_mix[mm_tube_label] = ops\n        end\n\n        show do\n            title \"Vortex and Spin Down\"\n\n            check \"Vortex the master mix tubes briefly and spin down\"\n        end\n\n        ops_by_master_mix\n    end\n\n    # Build table for volumes of master mix components\n    #\n    # @param inputs [Array\u003cFixNum\u003e] input item IDs\n    # @param input_names [Array\u003cString\u003e] input names\n    # @param composition [PCRComposition]\n    # @param mult [Float] Amount to multiply each component volume by to account for\n    #   pipetting error\n    # @return [Array\u003cArray\u003e] a 2D array formatted for the `table` method in Krill\n    def master_mix_table(inputs:, input_names:, composition:, mult:)\n        header = [\n            \"#{composition.polymerase.display_name} #{composition.polymerase.item}\",\n            \"#{composition.dye.display_name} #{composition.dye.item}\",\n            composition.water.display_name\n        ]\n\n        row = [\n            composition.polymerase.add_in_table(mult),\n            composition.dye.add_in_table(mult),\n            composition.water.add_in_table(mult)\n        ]\n\n        input_names.each_with_index do |input_name, i|\n            header \u003c\u003c \"#{input_name} #{inputs[i]}\"\n            row \u003c\u003c composition.input(input_name).add_in_table(mult)\n        end\n\n        [header, row].transpose\n    end\n\n    # Dispenses master mixes for PCR\n    # Assumes all operations in ops_by_master_mix hash are from the same program\n    #\n    # @param output_name [String] output name\n    # @param ops_by_master_mix [Hash{String =\u003e Array\u003cOperation\u003e}] hash of operations\n    #   grouped by tube labels\n    # @param composition [PCRComposition]\n    def dispense_master_mix(output_name:, ops_by_master_mix:, composition:, mult: 1.0)\n        coll = ops_by_master_mix.values.first.first.output(output_name).collection\n        coll_display = \"#{coll}-#{TEST}\"\n\n        mm_vol = composition.sum_added_components * mult\n        divide = composition.volume * mult \u003e 100\n\n        if divide\n            ops = ops_by_master_mix.values.flatten\n            labels = ops.map { |op| coll_id_display(op, output_name, role=\"output\", hide_id=true) }\n            show do\n                title \"Divide Master Mix\"\n\n                note \"Get #{ops.length} 1.5 ml microfuge tubes and label them\"\\\n                     \" #{labels.to_sentence}\"\n            end\n        end\n\n        destination = divide ? \"microfuge tube\" : \"#{coll_display} position\"\n\n        master_mix_table = []\n        master_mix_table[0] = [\n            \"MM tube\",\n            destination\n        ]\n\n        ops_by_master_mix.each do |master_mix, ops|\n            ops.each do |op|\n                pos = coll_id_display(op, output_name, role=\"output\", hide_id=true)\n                row = [\n                    master_mix,\n                    { content: pos, check: true }\n                ]\n                master_mix_table.append(row)\n            end\n        end\n\n        show do\n            title \"Dispense Master Mix\"\n            note \"Dispense #{mm_vol} #{MICROLITERS} of each master mix\"\\\n                 \" into the indicated \u003cb\u003e#{destination}\u003c/b\u003e\"\n            table master_mix_table\n        end\n    end\n\n    # Dispenses a component\n    #\n    # @param input_name [String] input name of component\n    # @param output_name [String] output name\n    # @param ops [OperationList, Array\u003cOperation\u003e] operations\n    # @param composition [PCRComposition]\n    # @param mult [Float] Amount to multiply each component volume by to account for\n    #   pipetting error\n    def dispense_component(input_name:, output_name:, ops:, composition:, mult: 1.0)\n        coll = ops.first.output(output_name).collection\n        coll_display = \"#{coll}-#{TEST}\"\n\n        component = composition.input(input_name)\n        comp_vol = component.adjusted_qty(mult=mult, round=1, checkable=false)\n\n        divide = composition.volume * mult \u003e 100\n        destination = divide ? \"microfuge tube\" : \"#{coll_display} position\"\n\n        uniq_inputs = ops.map { |op| op.input(input_name).item }.uniq\n        if uniq_inputs.length == 1\n            from_header = \"#{uniq_inputs.first} position\"\n            hide_input_id = true\n        else\n            from_header = \"#{input_name} ID\"\n            hide_input_id = false\n        end\n\n        dispense_table = []\n        dispense_table[0] = [\n            from_header,\n            destination\n        ]\n\n        ops.each do |op|\n            from_pos = coll_id_display(op, input_name, role=\"input\", hide_id=hide_input_id)\n            to_pos = coll_id_display(op, output_name, role=\"output\", hide_id=true)\n            row = [from_pos, { content: to_pos, check: true }]\n            dispense_table.append(row)\n        end\n\n        show do\n            title \"Dispense #{input_name.pluralize}\"\n            \n            if input_name.pluralize == \"Templates\" \n                \n                check \"Dispense #{comp_vol} #{MICROLITERS} of each template in the indicated \u003cb\u003e#{destination}\u003c/b\u003e and close cap for each well after template is added\"\n                table dispense_table\n                note \"Vortex and spin down test stripwells\"\n                \n            else \n                \n                check \"Dispense #{comp_vol} #{MICROLITERS} of each #{input_name}\"\\\n                      \" into the indicated \u003cb\u003e#{destination}\u003c/b\u003e\"\n                table dispense_table\n                \n            end\n        end\n    end\n\nend"}},{"library":{"name":"PCRComposition","category":"PCR Libs","code_source":"needs \"PCR Libs/PCRCompositionDefinitions\"\n\n# Factory class for instantiating `PCRComposition`\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PCRCompositionFactory\n  # Instantiates `PCRComposition`\n  # Either `component_data` or `program_name` must be passed\n  #\n  # @param component_data [Hash] a hash enumerating the components\n  # @param program_name [String] the name of one of the default component hashes\n  # @return [PCRComposition]\n  def self.build(component_data: nil, program_name: nil)\n    PCRComposition.new(component_data: component_data, program_name: program_name)\n  end\nend\n\n# Models the composition of a polymerase chain reaction\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n# @note As much as possible, Protocols using this class should draw input names \n#   from `CommonInputOutputNames`\nclass PCRComposition\n  include PCRCompositionDefinitions\n\n  attr_accessor :components\n\n  # Instantiates the class\n  # Either `component_data` or `program_name` must be passed\n  #\n  # @param component_data [Hash] a hash enumerating the components\n  # @param program_name [String] the name of one of the default component hashes\n  # @return [PCRComposition]\n  def initialize(component_data: nil, program_name: nil)\n    if component_data.blank? \u0026\u0026 program_name.blank?\n      msg = \"Unable to initialize PCRComposition.\" \\\n        \" Either `component_data` or `program_name` is required.\"\n      raise ProtocolError.new(msg)\n    elsif program_name.present?\n      component_data = get_composition_def(name: program_name)\n    end\n\n    @components = []\n    component_data.each { |k, c| components.append(ReactionComponent.new(c)) }\n  end\n\n  # Specifications for the dye component\n  # @return (see #input)\n  def dye\n    input(DYE)\n  end\n\n  # Specifications for the polymerase component\n  # @return (see #input)\n  def polymerase\n    input(POLYMERASE)\n  end\n\n  # Specifications for the forward primer component\n  # @return (see #input)\n  def forward_primer\n    input(FORWARD_PRIMER)\n  end\n\n  # Specifications for the reverse primer component\n  # @return (see #input)\n  def reverse_primer\n    input(REVERSE_PRIMER)\n  end\n\n  # Specifications for the template component\n  # @return [ReactionComponent]\n  def template\n    input(TEMPLATE)\n  end\n\n  # Specifications for the water component\n  # @return (see #input)\n  def water\n    input(WATER)\n  end\n\n  # Retrieves components by input name\n  # Generally the named methods should be used.\n  # However, this method can be convenient in loops, especially when\n  #   the Protocol draws input names from `CommonInputOutputNames`\n  #\n  # @param input_name [String] the name of the component to be retrieved\n  # @return [ReactionComponent]\n  def input(input_name)\n    components.find { |c| c.input_name == input_name }\n  end\n\n  # Displays the total reaction volume with units\n  #\n  # @todo Make this work better with units other than microliters\n  # @return [String]\n  def qty_display\n    Units.qty_display({ qty: volume, units: MICROLITERS })\n  end\n\n  # The total reaction volume\n  # @note Rounds to one decimal place\n  # @return [Float]\n  def volume\n    sum_components\n  end\n\n  # The total reaction volume\n  # @param round [Fixnum] the number of decimal places to round to\n  # @return [Float]\n  def sum_components(round = 1)\n    components.map { |c| c.qty }.reduce(:+).round(round)\n  end\n\n  # The total volume of all components that have been added\n  # @param (see #sum_components)\n  # @return (see #sum_components)\n  def sum_added_components(round = 1)\n    added_components.map { |c| c.qty }.reduce(:+).round(round)\n  end\n\n  # Gets the components that have been added\n  # @return [Array\u003cReactionComponent\u003e]\n  def added_components\n    components.select { |c| c.added? }\n  end\nend\n\n# Models a component of a biochemical reaction\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass ReactionComponent\n  include Units\n\n  attr_reader :input_name, :qty, :units, :sample, :item\n  attr_accessor :added\n\n  # Instantiates the class\n  #\n  # @param input_name [String] the name of the component\n  # @param qty [Numeric] the quantity of this component to be added to a single reaction\n  # @param units [String] the units of `qty`\n  # @param sample_name [String] the name of the Aquarium Sample to be used for this component\n  # @param object_name [String] the ObjectType (Container) that this component should be found in\n  def initialize(input_name:, qty:, units:, sample_name: nil, object_name: nil)\n    @input_name = input_name\n    @qty = qty\n    @units = units\n    @sample = sample_name ? Sample.find_by_name(sample_name) : nil\n\n    if sample \u0026\u0026 object_name\n      @item = sample.in(object_name).first\n    else\n      @item = nil\n    end\n\n    @added = false\n  end\n\n  # The input name, formatted for display in protocols\n  # @return [String]\n  def display_name\n    input_name\n  end\n\n  # Displays the volume (`qty`) with units\n  #\n  # @return [String]\n  def qty_display(round = 1)\n    Units.qty_display({ qty: qty.round(round), units: units })\n  end\n\n  # Adjusts the qty by a given factor and, if needed, makes it checkable in a table\n  #\n  # @param mult [Float] the factor to multiply `qty` by\n  # @param round [FixNum] the number of places to round the result to\n  # @param checkable [Boolean] whether to make the result checkable in a table\n  # @return [Numeric, Hash]\n  def adjusted_qty(mult = 1.0, round = 1, checkable = true)\n    adj_qty = (qty * mult).round(round)\n    adj_qty = { content: adj_qty, check: true } if checkable\n    adj_qty\n  end\n\n  # provides the `qty` for display in a table, and markes it as `added`\n  #\n  # @param (see #adjusted_qty)\n  # @return (see #adjusted_qty)\n  def add_in_table(mult = 1.0, round = 1, checkable = true)\n    @added = true\n    adjusted_qty(mult, round, checkable)\n  end\n\n  # Checks if `self` has been added\n  # @return [Boolean]\n  def added?\n    added\n  end\nend\n"}},{"library":{"name":"PCRCompositionDefinitions","category":"PCR Libs","code_source":"needs \"Standard Libs/Units\"\nneeds \"Standard Libs/CommonInputOutputNames\"\n\nmodule PCRCompositionDefinitions\n  \n  include Units\n  include CommonInputOutputNames\n\n  POLYMERASE = \"Polymerase\"\n  POLYMERASE_SAMPLE = \"Kapa HF Master Mix\"\n  POLYMERASE_OBJECT = \"Enzyme Stock\"\n  DYE = \"Dye\"\n  DYE_SAMPLE = \"Eva Green\"\n  DYE_OBJECT = \"Screw Cap Tube\"\n  WATER = \"Molecular Grade Water\"\n  MASTER_MIX = \"Master Mix\"\n\n  PRIMER_PROBE_MIX = \"Combined Primer/Probe Mix\"\n\n  COMPONENTS = {\n    # qPCR2: 2nd qPCR in NGS prep.\n    \"qPCR1\" =\u003e {\n      polymerase:     {input_name: POLYMERASE,        qty: 16,    units: MICROLITERS,\n                       sample_name: POLYMERASE_SAMPLE, \n                       object_name: POLYMERASE_OBJECT},\n      forward_primer: {input_name: FORWARD_PRIMER,    qty: 0.16,  units: MICROLITERS},\n      reverse_primer: {input_name: REVERSE_PRIMER,    qty: 0.16,  units: MICROLITERS},\n      dye:            {input_name: DYE,               qty: 1.6,   units: MICROLITERS,\n                       sample_name: DYE_SAMPLE,\n                       object_name: DYE_OBJECT},\n      water:          {input_name: WATER,             qty: 6.58,  units: MICROLITERS},\n      template:       {input_name: TEMPLATE,          qty: 7.5,   units: MICROLITERS}\n    },\n\n    # qPCR2: 2nd qPCR in NGS prep. reverse primer is indexed primer.\n    \"qPCR2\" =\u003e {\n      polymerase:     {input_name: POLYMERASE,        qty: 25,    units: MICROLITERS,\n                       sample_name: POLYMERASE_SAMPLE, \n                       object_name: POLYMERASE_OBJECT},\n      forward_primer: {input_name: FORWARD_PRIMER,    qty: 2.5,   units: MICROLITERS},\n      reverse_primer: {input_name: REVERSE_PRIMER,    qty: 2.5,   units: MICROLITERS},\n      dye:            {input_name: DYE,               qty: 2.5,   units: MICROLITERS,\n                       sample_name: DYE_SAMPLE,\n                       object_name: DYE_OBJECT},\n      water:          {input_name: WATER,             qty: 15.5,  units: MICROLITERS},\n      template:       {input_name: TEMPLATE,          qty: 2,     units: MICROLITERS}\n    },\n\n    # LIBqPCR1: 1st qPCR in Libray prep. if sublibrary primers exist they are used here.\n    \"lib_qPCR1\" =\u003e {\n      polymerase:     {input_name: POLYMERASE,        qty: 12.5,  units: MICROLITERS,\n                       sample_name: POLYMERASE_SAMPLE, \n                       object_name: POLYMERASE_OBJECT},\n      forward_primer: {input_name: FORWARD_PRIMER,    qty: 0.75,  units: MICROLITERS},\n      reverse_primer: {input_name: REVERSE_PRIMER,    qty: 0.75,  units: MICROLITERS},\n      dye:            {input_name: DYE,               qty: 1.25,  units: MICROLITERS,\n                       sample_name: DYE_SAMPLE,\n                       object_name: DYE_OBJECT},\n      water:          {input_name: WATER,             qty: 8.75,  units: MICROLITERS},\n      template:       {input_name: TEMPLATE,          qty: 1,     units: MICROLITERS}\n    },\n\n    # LIBqPCR2: 2nd qPCR in Libray prep. overhangs compatible with cloning vector are added here.\n    \"lib_qPCR2\" =\u003e {\n      polymerase:     {input_name: POLYMERASE,        qty: 25,    units: MICROLITERS,\n                       sample_name: POLYMERASE_SAMPLE, \n                       object_name: POLYMERASE_OBJECT},\n      forward_primer: {input_name: FORWARD_PRIMER,    qty: 1.5,   units: MICROLITERS},\n      reverse_primer: {input_name: REVERSE_PRIMER,    qty: 1.5,   units: MICROLITERS},\n      dye:            {input_name: DYE,               qty: 2.5,   units: MICROLITERS,\n                       sample_name: DYE_SAMPLE,\n                       object_name: DYE_OBJECT},\n      water:          {input_name: WATER,             qty: 17.5,  units: MICROLITERS},\n      template:       {input_name: TEMPLATE,          qty: 2,     units: MICROLITERS}\n    },\n\n    # CDC COVID-19 detection protocol\n    \"CDC_TaqPath_CG\" =\u003e {\n      water:             {input_name: WATER,             qty: 8.5,  units: MICROLITERS},\n      primer_probe_mix:  {input_name: PRIMER_PROBE_MIX,  qty: 1.5,  units: MICROLITERS},\n      master_mix:        {input_name: MASTER_MIX,        qty: 5.0,  units: MICROLITERS,\n                          sample_name: \"TaqPath 1-Step RT-qPCR Master Mix (4x)\"},\n      template:          {input_name: TEMPLATE,          qty: 5.0,  units: MICROLITERS}\n    },\n\n    # CDC COVID-19 detection protocol\n    \"CDC_qScript_XLT_ToughMix\" =\u003e {\n      water:             {input_name: WATER,             qty: 3.5,  units: MICROLITERS},\n      primer_probe_mix:  {input_name: PRIMER_PROBE_MIX,  qty: 1.5,  units: MICROLITERS},\n      master_mix:        {input_name: MASTER_MIX,        qty: 10,   units: MICROLITERS,\n                          sample_name: \"qScript XLT One-Step RT-qPCR ToughMix (2X)\"},\n      template:          {input_name: TEMPLATE,          qty: 5.0,  units: MICROLITERS}\n    },\n\n    # CDC COVID-19 detection protocol\n    \"CDC_UltraPlex_ToughMix\" =\u003e {\n      water:             {input_name: WATER,             qty: 8.5,  units: MICROLITERS},\n      primer_probe_mix:  {input_name: PRIMER_PROBE_MIX,  qty: 1.5,  units: MICROLITERS},\n      master_mix:        {input_name: MASTER_MIX,        qty: 5.0,  units: MICROLITERS,        \n                          sample_name: \"UltraPlex 1-Step ToughMix (4X)\"},\n      template:          {input_name: TEMPLATE,          qty: 5.0,  units: MICROLITERS}\n    },\n\n    # CDC COVID-19 detection protocol\n    \"CDC_GoTaq_Probe_1-Step\" =\u003e {\n      water:             {input_name: WATER,             qty: 3.1,  units: MICROLITERS},\n      primer_probe_mix:  {input_name: PRIMER_PROBE_MIX,  qty: 1.5,  units: MICROLITERS},\n      master_mix:        {input_name: MASTER_MIX,        qty: 10,   units: MICROLITERS,        \n                          sample_name: \"GoTaq Probe qPCR Master Mix with dUTP\"},\n      rt_mix:            {input_name: \"RT Mix\",          qty: 0.4,  units: MICROLITERS,        \n                          sample_name: \"Go Script RT Mix for 1-Step RT-qPCR\"},\n      template:          {input_name: TEMPLATE,          qty: 5.0,  units: MICROLITERS}\n    }\n  }\n\n  def get_composition_def(name:)\n    PCRCompositionDefinitions::COMPONENTS[name]\n  end\n\nend"}},{"library":{"name":"PCRProgram","category":"PCR Libs","code_source":"needs \"PCR Libs/PCRProgramDefinitions\"\n\n# Factory class for instantiating `PCRProgram`\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PCRProgramFactory\n  # Instantiates `PCRComposition`\n  #\n  # @param program_name [String] the name of one of the default program hashes\n  # @param volume [Numeric] the reaction volume in MICROLITERS\n  # @return [PCRProgram]\n  def self.build(program_name:, volume: nil)\n    PCRProgram.new(program_name: program_name, volume: volume)\n  end\nend\n\n# Models a thermocycler program\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PCRProgram\n\n  include PCRProgramDefinitions\n\n  attr_reader :program_name, :program_template_name, :layout_template_name\n  attr_reader :steps, :volume\n\n  # Instantiates the class\n  #\n  # @param program_name [String] the name of one of the default program hashes\n  # @param volume [Numeric] the reaction volume in MICROLITERS\n  # @return [PCRProgram]\n  def initialize(args = {})\n    @program_name = args[:program_name]\n    program = get_program_def(name: program_name)\n    @program_template_name = program[:program_template_name]\n    @name = @program_template\n    @plate = program[:plate]\n    @layout_template_name = program[:layout_template_name]\n    @steps = {}\n    program[:steps].each { |k, v| @steps[k] = PCRStep.create_from(v) }\n    @volume = args[:volume] || program[:volume]\n  end\n\n  # @deprecated Use {#program_template_name}\n  def name\n    program_template_name\n  end\n\n  # @deprecated Use {#layout_template_name}\n  def plate\n    layout_template_name\n  end\n\n  # Renders the thermocycler program as a table for `show` blocks\n  #\n  # @return [Array\u003cArray\u003e]\n  def table\n    table = []\n    steps.each do |k, v|\n      row = [\"#{k}\"] + v.display\n      table.append(row)\n    end\n    table\n  end\n\n  # TODO: This needs to be responsive to the actual program parameters\n  def final_step\n    \"the final step\"\n  end\nend\n\nclass PCRStep\n  def self.create_from(temperature: nil, duration: nil, goto: nil, times: nil)\n    if temperature \u0026\u0026 duration\n      IncubationStep.new(temperature: temperature, duration: duration)\n    elsif goto \u0026\u0026 times\n      GotoStep.new(destination: goto, times: times)\n    else\n      raise ProtocolError.new(\"Expected either an incubation or goto step\")\n    end\n  end\nend\n\nclass IncubationStep \n  attr_reader :temperature, :duration\n\n  def initialize(temperature: , duration:)\n    @temperature = temperature\n    @duration = duration\n  end\n\n  def display\n    [temperature_display, duration_display]\n  end\n\n  def temperature_display\n    Units.qty_display(temperature)\n  end\n\n  def duration_display\n    Units.qty_display(duration)\n  end\n  \nend\n\nclass GotoStep\n  attr_reader :destination, :times\n\n  def initialize(destination:, times:)\n    @destination = destination\n    @times = times\n  end\n\n  def display\n    [goto_display, times_display]\n  end\n\n  def goto_display\n    \"goto step #{destination}\"\n  end\n\n  def times_display\n    \"#{times} times\"\n  end\nend"}},{"library":{"name":"PCRProgramDefinitions","category":"PCR Libs","code_source":"needs \"Standard Libs/Units\"\n\nmodule PCRProgramDefinitions\n  \n  include Units\n  \n  PROGRAMS = {\n    \"qPCR1\" =\u003e {\n      program_template_name: \"NGS_qPCR1\", volume: 32, layout_template_name: \"NGS_qPCR1\",\n      steps: {\n        step1: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  3, units: MINUTES}},\n        step2: {temperature: {qty: 98, units: DEGREES_C}, duration: {qty: 15, units: SECONDS}},\n        step3: {temperature: {qty: 62, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n        step4: {temperature: {qty: 72, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n        step5: {goto: 2, times: 34},\n        step6: {temperature: {qty: 12, units: DEGREES_C}, duration: {qty: \"forever\", units: \"\"}}\n      }\n    },\n\n    \"qPCR2\" =\u003e {\n      program_template_name: \"NGS_qPCR2\", volume: 50, layout_template_name: \"NGS_qPCR1\",\n      steps: {\n        step1: {temperature: {qty: 98, units: DEGREES_C}, duration: {qty:  3, units: MINUTES}},\n        step2: {temperature: {qty: 98, units: DEGREES_C}, duration: {qty: 15, units: SECONDS}},\n        step3: {temperature: {qty: 64, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n        step4: {temperature: {qty: 72, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n        step5: {goto: 2, times: 29},\n        step6: {temperature: {qty: 72, units: DEGREES_C}, duration: {qty:  5, units: MINUTES}},\n        step7: {temperature: {qty: 12, units: DEGREES_C}, duration: {qty: \"forever\", units: \"\"}}\n      }\n    },\n\n    \"lib_qPCR1\" =\u003e {\n      program_template_name: \"LIB_qPCR1\", volume: 25, layout_template_name: \"LIB_qPCR\",\n      steps: {\n        step1: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  3, units: MINUTES}},\n        step2: {temperature: {qty: 98, units: DEGREES_C}, duration: {qty: 15, units: SECONDS}},\n        step3: {temperature: {qty: 65, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n        step4: {temperature: {qty: 72, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n        step5: {goto: 2, times: 34},\n        step6: {temperature: {qty: 72, units: DEGREES_C}, duration: {qty:  5, units: MINUTES}},\n        step7: {temperature: {qty: 12, units: DEGREES_C}, duration: {qty: \"forever\", units: \"\"}}\n      }\n    },\n\n    \"lib_qPCR2\" =\u003e {\n      program_template_name: \"LIB_qPCR2\", volume: 50, layout_template_name: \"LIB_qPCR\",\n      steps: {\n        step1: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  3, units: MINUTES}},\n        step2: {temperature: {qty: 98, units: DEGREES_C}, duration: {qty: 15, units: SECONDS}},\n        step3: {temperature: {qty: 65, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n        step4: {temperature: {qty: 72, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n        step5: {goto: 2, times: 34},\n        step6: {temperature: {qty: 72, units: DEGREES_C}, duration: {qty:  5, units: MINUTES}},\n        step7: {temperature: {qty: 12, units: DEGREES_C}, duration: {qty: \"forever\", units: \"\"}}\n      }\n    },\n\n    \"illumina_qPCR_quantification\" =\u003e {\n      program_template_name: \"illumina_qPCR_quantification_v1\", \n      layout_template_name: \"illumina_qPCR_plate_layout_v1\"\n    },\n\n    \"CDC_TaqPath_CG\" =\u003e {\n      program_template_name: \"CDC_TaqPath_CG\", volume: 20, layout_template_name: \"CDC_TaqPath_CG\",\n      steps: {\n        step1: {temperature: {qty: 25, units: DEGREES_C}, duration: {qty:  2, units: MINUTES}},\n        step2: {temperature: {qty: 50, units: DEGREES_C}, duration: {qty: 15, units: MINUTES}},\n        step3: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  2, units: MINUTES}},\n        step4: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  3, units: SECONDS}},\n        step5: {temperature: {qty: 55, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n        step6: {goto: 4, times: 44}\n      }\n    },\n\n    \"CDC_qScript_XLT_ToughMix\" =\u003e {\n      program_template_name: \"CDC_qScript_XLT_ToughMix\", volume: 20, layout_template_name: \"CDC_qScript_XLT_ToughMix\",\n      step1: {temperature: {qty: 50, units: DEGREES_C}, duration: {qty: 10, units: MINUTES}},\n      step2: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  3, units: MINUTES}},\n      step3: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  3, units: SECONDS}},\n      step4: {temperature: {qty: 55, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n      step5: {goto: 3, times: 44}\n    },\n\n    \"CDC_UltraPlex_ToughMix\" =\u003e {\n      program_template_name: \"CDC_UltraPlex_ToughMix\", volume: 20, layout_template_name: \"CDC_UltraPlex_ToughMix\",\n      step1: {temperature: {qty: 50, units: DEGREES_C}, duration: {qty: 10, units: MINUTES}},\n      step2: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  3, units: MINUTES}},\n      step3: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  3, units: SECONDS}},\n      step4: {temperature: {qty: 55, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n      step5: {goto: 3, times: 44}\n    },\n\n    \"CDC_GoTaq_Probe_1-Step\" =\u003e {\n      program_template_name: \"CDC_GoTaq_Probe_1-Step\", volume: 20, layout_template_name: \"CDC_GoTaq_Probe_1-Step\",\n      step1: {temperature: {qty: 45, units: DEGREES_C}, duration: {qty: 15, units: MINUTES}},\n      step2: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  2, units: MINUTES}},\n      step3: {temperature: {qty: 95, units: DEGREES_C}, duration: {qty:  3, units: SECONDS}},\n      step4: {temperature: {qty: 55, units: DEGREES_C}, duration: {qty: 30, units: SECONDS}},\n      step5: {goto: 3, times: 44}\n    }\n  }\n\n  def get_program_def(name:)\n    PCRProgramDefinitions::PROGRAMS[name]\n  end\n\nend"}}]}