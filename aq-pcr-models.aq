{"config":{"title":"Aquarium PCR Models","description":"Libraries to model PCR composition and program, and help with master mixes","copyright":"University of Washington","version":"0.0.1","authors":[{"name":"Devin Strickland","affiliation":"University of Washington"}],"maintainer":{"name":"Devin Strickland","email":"dvn.strcklnd@gmail.com"},"acknowledgements":null,"github":{"user":"dvnstrcklnd","repo":"aq-pcr-models"},"keywords":null,"aquadoc_version":"1.0.2","aquarium_version":"\u003c%= Bioturk::Application.config.aquarium_version %\u003e"},"components":[{"library":{"name":"MasterMixHelper","category":"PCR Libs","code_source":"needs \"Standard Libs/Units\"\nneeds \"Standard Libs/CommonInputOutputNames\"\n\n# Contains methods for assembling and dispensing master mixes\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nmodule MasterMixHelper\n\n    include CommonInputOutputNames\n    include Units\n\n    # TODO: Get this out of here.\n    TEST = \"TEST\"\n\n    # Group operations by multiple inputs\n    # @todo Make the grouped Operations be OperationLists\n    #\n    # @param input_names [Array\u003cString\u003e] names of inputs to be included in grouping\n    # @param ops [OperationList, Array\u003cOperation\u003e] operations to be grouped\n    # @return [Array(Array\u003cString\u003e, Hash{Array\u003cFixNum\u003e =\u003e Array\u003cOperation\u003e})] the input IDs\n    #   with singletons eliminated, followed by the grouped operations\n    def group_ops_by_inputs(input_names:, ops:)\n        input_names = eliminate_singletons(input_names: input_names, ops: ops)\n        grouped_ops = ops.group_by { |op| input_item_id_array(input_names: input_names, op: op) }\n        [input_names, grouped_ops]\n    end\n\n    # Remove input names from the list where each operation is a different input item\n    #\n    # @param input_names [Array\u003cString\u003e] input names to be tested and, if appropriate, eliminated\n    # @param ops [OperationList, Array\u003cOperation\u003e] operations\n    # @return [Array\u003cString\u003e] the input names with singletons eliminated\n    def eliminate_singletons(input_names:, ops:)\n        input_names.reject { |n| singletons?(input_name: n, ops: ops) }\n    end\n\n    # Tests whether each operation has a different item for a given input name and\n    #   returns true if each is different\n    #\n    # @param input_name [String] input name to be tested\n    # @param ops [OperationList, Array\u003cOperation\u003e] operations\n    # @return [Boolean]\n    def singletons?(input_name:, ops:)\n        ops.map { |op| item_id(input_name: input_name, op: op) }.uniq.length == ops.length\n    end\n\n    # Gets the ID for the Item or Part specified by a given input name\n    #\n    # @param input_name [String] input name to be tested\n    # @param op [Operation]\n    # @return [FixNum] the Item or Part ID\n    def item_id(input_name:, op:)\n        fv = op.input(input_name)\n        fv.part.try(:id) || fv.item.id\n    end\n\n    # Maps Item IDs for a given list of input names and a given operation\n    #\n    # @param input_names [Array\u003cString\u003e] input names to be mapped\n    # @param op [Operation]\n    # @return [Array\u003cFixNum\u003e]\n    def input_item_id_array(input_names:, op:)\n        input_names.map { |n| op.input(n).child_item_id }\n    end\n\n    # Makes master mix(es) for a set of operations\n    # Assumes that all operations have the same PCR program\n    #\n    # @param grouped_ops [Hash{Array\u003cFixNum\u003e =\u003e Array\u003cOperation\u003e}] hash of operations\n    #   grouped by input IDs\n    # @param input_names [Array\u003cString\u003e] input names corresponding to grouped_ops keys\n    # @param composition [PCRComposition]\n    # @param mult [Float] Amount to multiply each component volume by to account for\n    #   pipetting error\n    # @return [Hash{String =\u003e Array\u003cOperation\u003e}] hash of operations grouped by tube labels\n    def make_master_mixes(grouped_ops:, input_names:, composition:, mult: 1.0)\n        ops_by_master_mix = {}\n\n        grouped_ops.each_with_index do |(inputs, ops), i|\n            mm_tube_label = \"MM#{i+1}\"\n            this_mult = mult * ops.length\n\n            master_mix_table = master_mix_table(\n                inputs: inputs,\n                input_names: input_names,\n                composition: composition,\n                mult: this_mult\n            )\n\n            show do\n                title \"Make Master Mix #{mm_tube_label}\"\n\n                check \"Get a 1.5mL tube and label it \u003cb\u003e#{mm_tube_label}\u003c/b\u003e.\"\n                note \"Add reaction components as indicated:\"\n                table master_mix_table\n            end\n\n            ops_by_master_mix[mm_tube_label] = ops\n        end\n\n        show do\n            title \"Vortex and Spin Down\"\n\n            check \"Vortex the master mix tubes briefly and spin down\"\n        end\n\n        ops_by_master_mix\n    end\n\n    # Build table for volumes of master mix components\n    #\n    # @param inputs [Array\u003cFixNum\u003e] input item IDs\n    # @param input_names [Array\u003cString\u003e] input names\n    # @param composition [PCRComposition]\n    # @param mult [Float] Amount to multiply each component volume by to account for\n    #   pipetting error\n    # @return [Array\u003cArray\u003e] a 2D array formatted for the `table` method in Krill\n    def master_mix_table(inputs:, input_names:, composition:, mult:)\n        header = [\n            \"#{composition.polymerase.display_name} #{composition.polymerase.item}\",\n            \"#{composition.dye.display_name} #{composition.dye.item}\",\n            composition.water.display_name\n        ]\n\n        row = [\n            composition.polymerase.add_in_table(mult),\n            composition.dye.add_in_table(mult),\n            composition.water.add_in_table(mult)\n        ]\n\n        input_names.each_with_index do |input_name, i|\n            header \u003c\u003c \"#{input_name} #{inputs[i]}\"\n            row \u003c\u003c composition.input(input_name).add_in_table(mult)\n        end\n\n        [header, row].transpose\n    end\n\n    # Dispenses master mixes for PCR\n    # Assumes all operations in ops_by_master_mix hash are from the same program\n    #\n    # @param output_name [String] output name\n    # @param ops_by_master_mix [Hash{String =\u003e Array\u003cOperation\u003e}] hash of operations\n    #   grouped by tube labels\n    # @param composition [PCRComposition]\n    def dispense_master_mix(output_name:, ops_by_master_mix:, composition:, mult: 1.0)\n        coll = ops_by_master_mix.values.first.first.output(output_name).collection\n        coll_display = \"#{coll}-#{TEST}\"\n\n        mm_vol = composition.sum_added_components * mult\n        divide = composition.volume * mult \u003e 100\n\n        if divide\n            ops = ops_by_master_mix.values.flatten\n            labels = ops.map { |op| coll_id_display(op, output_name, role=\"output\", hide_id=true) }\n            show do\n                title \"Divide Master Mix\"\n\n                note \"Get #{ops.length} 1.5 ml microfuge tubes and label them\"\\\n                     \" #{labels.to_sentence}\"\n            end\n        end\n\n        destination = divide ? \"microfuge tube\" : \"#{coll_display} position\"\n\n        master_mix_table = []\n        master_mix_table[0] = [\n            \"MM tube\",\n            destination\n        ]\n\n        ops_by_master_mix.each do |master_mix, ops|\n            ops.each do |op|\n                pos = coll_id_display(op, output_name, role=\"output\", hide_id=true)\n                row = [\n                    master_mix,\n                    { content: pos, check: true }\n                ]\n                master_mix_table.append(row)\n            end\n        end\n\n        show do\n            title \"Dispense Master Mix\"\n            note \"Dispense #{mm_vol} #{MICROLITERS} of each master mix\"\\\n                 \" into the indicated \u003cb\u003e#{destination}\u003c/b\u003e\"\n            table master_mix_table\n        end\n    end\n\n    # Dispenses a component\n    #\n    # @param input_name [String] input name of component\n    # @param output_name [String] output name\n    # @param ops [OperationList, Array\u003cOperation\u003e] operations\n    # @param composition [PCRComposition]\n    # @param mult [Float] Amount to multiply each component volume by to account for\n    #   pipetting error\n    def dispense_component(input_name:, output_name:, ops:, composition:, mult: 1.0)\n        coll = ops.first.output(output_name).collection\n        coll_display = \"#{coll}-#{TEST}\"\n\n        component = composition.input(input_name)\n        comp_vol = component.adjusted_qty(mult=mult, round=1, checkable=false)\n\n        divide = composition.volume * mult \u003e 100\n        destination = divide ? \"microfuge tube\" : \"#{coll_display} position\"\n\n        uniq_inputs = ops.map { |op| op.input(input_name).item }.uniq\n        if uniq_inputs.length == 1\n            from_header = \"#{uniq_inputs.first} position\"\n            hide_input_id = true\n        else\n            from_header = \"#{input_name} ID\"\n            hide_input_id = false\n        end\n\n        dispense_table = []\n        dispense_table[0] = [\n            from_header,\n            destination\n        ]\n\n        ops.each do |op|\n            from_pos = coll_id_display(op, input_name, role=\"input\", hide_id=hide_input_id)\n            to_pos = coll_id_display(op, output_name, role=\"output\", hide_id=true)\n            row = [from_pos, { content: to_pos, check: true }]\n            dispense_table.append(row)\n        end\n\n        show do\n            title \"Dispense #{input_name.pluralize}\"\n            \n            if input_name.pluralize == \"Templates\" \n                \n                check \"Dispense #{comp_vol} #{MICROLITERS} of each template in the indicated \u003cb\u003e#{destination}\u003c/b\u003e and close cap for each well after template is added\"\n                table dispense_table\n                note \"Vortex and spin down test stripwells\"\n                \n            else \n                \n                check \"Dispense #{comp_vol} #{MICROLITERS} of each #{input_name}\"\\\n                      \" into the indicated \u003cb\u003e#{destination}\u003c/b\u003e\"\n                table dispense_table\n                \n            end\n        end\n    end\n\nend"}},{"library":{"name":"PCRComposition","category":"PCR Libs","code_source":"needs \"Standard Libs/Units\"\nneeds \"Standard Libs/CommonInputOutputNames\"\n\n# Models the composition of a polymerase chain reaction\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n# @note As much as possible, Protocols using this class should drawn input names from `CommonInputOutputNames`\nclass PCRComposition\n\n    include CommonInputOutputNames, Units\n\n    POLYMERASE = \"Polymerase\"\n    POLYMERASE_SAMPLE = \"Kapa HF Master Mix\"\n    POLYMERASE_OBJECT = \"Enzyme Stock\"\n    DYE = \"Dye\"\n    DYE_SAMPLE = \"Eva Green\"\n    DYE_OBJECT = \"Screw Cap Tube\"\n    WATER = \"Molecular Grade Water\"\n\n    COMPONENTS = {\n        \"qPCR1\" =\u003e {\n            polymerase:     {input_name: POLYMERASE,        qty: 16,    units: MICROLITERS},\n            forward_primer: {input_name: FORWARD_PRIMER,    qty: 0.16,  units: MICROLITERS},\n            reverse_primer: {input_name: REVERSE_PRIMER,    qty: 0.16,  units: MICROLITERS},\n            dye:            {input_name: DYE,               qty: 1.6,   units: MICROLITERS},\n            water:          {input_name: WATER,             qty: 6.58,  units: MICROLITERS},\n            template:       {input_name: TEMPLATE,          qty: 7.5,   units: MICROLITERS}\n        },\n\n        # qPCR2: 2nd qPCR in NGS prep. reverse primer is indexed primer.\n        \"qPCR2\" =\u003e {\n            polymerase:     {input_name: POLYMERASE,        qty: 25,    units: MICROLITERS},\n            forward_primer: {input_name: FORWARD_PRIMER,    qty: 2.5,   units: MICROLITERS},\n            reverse_primer: {input_name: REVERSE_PRIMER,    qty: 2.5,   units: MICROLITERS},\n            dye:            {input_name: DYE,               qty: 2.5,   units: MICROLITERS},\n            water:          {input_name: WATER,             qty: 15.5,  units: MICROLITERS},\n            template:       {input_name: TEMPLATE,          qty: 2,     units: MICROLITERS}\n        },\n\n        # LIBqPCR1: 1st qPCR in Libray prep. if sublibrary primers exist they are used here.\n        \"lib_qPCR1\" =\u003e {\n            polymerase:     {input_name: POLYMERASE,        qty: 12.5,  units: MICROLITERS},\n            forward_primer: {input_name: FORWARD_PRIMER,    qty: 0.75,  units: MICROLITERS},\n            reverse_primer: {input_name: REVERSE_PRIMER,    qty: 0.75,  units: MICROLITERS},\n            dye:            {input_name: DYE,               qty: 1.25,  units: MICROLITERS},\n            water:          {input_name: WATER,             qty: 8.75,  units: MICROLITERS},\n            template:       {input_name: TEMPLATE,          qty: 1,     units: MICROLITERS}\n        },\n\n        # LIBqPCR2: 2nd qPCR in Libray prep. overhangs compatible with cloning vector are added here.\n        \"lib_qPCR2\" =\u003e {\n            polymerase:     {input_name: POLYMERASE,        qty: 25,    units: MICROLITERS},\n            forward_primer: {input_name: FORWARD_PRIMER,    qty: 1.5,   units: MICROLITERS},\n            reverse_primer: {input_name: REVERSE_PRIMER,    qty: 1.5,   units: MICROLITERS},\n            dye:            {input_name: DYE,               qty: 2.5,   units: MICROLITERS},\n            water:          {input_name: WATER,             qty: 17.5,  units: MICROLITERS},\n            template:       {input_name: TEMPLATE,          qty: 2,     units: MICROLITERS}\n        },\n    }\n\n    attr_accessor :components\n\n    # Instantiates the class\n    # Either `component_data` or `program_name` must be passed\n    #\n    # @param components [Hash] a hash enumerating the components\n    # @param program_name [String] a key specifying one of the default component hashes\n    def initialize(component_data: nil, program_name: nil)\n        if component_data.blank? \u0026\u0026 program_name.blank?\n            raise \"Unable to initialize PCRComposition. Either `component_data` or `program_name` is required.\"\n        elsif program_name.present?\n            component_data = PCRComposition::COMPONENTS[program_name]\n        end\n\n        component_data[:dye] = default_dye.merge(component_data[:dye])\n        component_data[:polymerase] = default_polymerase.merge(component_data[:polymerase])\n\n        @components = []\n        component_data.each { |k,c| components.append(ReactionComponent.new(c)) }\n    end\n\n    # Provides default Sample and ObjectType for polymerase\n    # @private\n    # @return [Hash]\n    def default_polymerase\n        {\n            sample_name: POLYMERASE_SAMPLE,\n            object_name: POLYMERASE_OBJECT\n        }\n    end\n\n    # Provides default Sample and ObjectType for dye\n    # @private\n    # @return [Hash]\n    def default_dye\n        {\n            sample_name: DYE_SAMPLE,\n            object_name: DYE_OBJECT\n        }\n    end\n\n    # Specifications for the dye component\n    # @return (see #input)\n    def dye\n        input(DYE)\n    end\n\n    # Specifications for the polymerase component\n    # @return (see #input)\n    def polymerase\n        input(POLYMERASE)\n    end\n\n    # Specifications for the forward primer component\n    # @return (see #input)\n    def forward_primer\n        input(FORWARD_PRIMER)\n    end\n\n    # Specifications for the reverse primer component\n    # @return (see #input)\n    def reverse_primer\n        input(REVERSE_PRIMER)\n    end\n\n    # Specifications for the template component\n    # @return [ReactionComponent]\n    def template\n        input(TEMPLATE)\n    end\n\n    # Specifications for the water component\n    # @return (see #input)\n    def water\n        input(WATER)\n    end\n\n    # Retrieves components by input name\n    # Generally the named methods should be used.\n    # However, this method can be convenient in loops, especially when\n    #   the Protocol draws input names from `CommonInputOutputNames`\n    #\n    # @param input_name [String] the name of the component to be retrieved\n    # @return [ReactionComponent]\n    def input(input_name)\n        components.find { |c| c.input_name == input_name }\n    end\n\n    # Displays the total reaction volume with units\n    #\n    # @todo Make this work better with units other than microliters\n    # @return [String]\n    def qty_display\n        Units.qty_display({ qty: volume, units: MICROLITERS })\n    end\n\n    # The total reaction volume\n    # @note Rounds to one decimal place\n    # @return [Float]\n    def volume\n        sum_components\n    end\n\n    # The total reaction volume\n    # @param round [Fixnum] the number of decimal places to round to\n    # @return [Float]\n    def sum_components(round=1)\n        components.map{ |c| c.qty }.reduce(:+).round(round)\n    end\n\n    # The total volume of all components that have been added\n    # @param (see #sum_components)\n    # @return (see #sum_components)\n    def sum_added_components(round=1)\n        added_components.map{ |c| c.qty }.reduce(:+).round(round)\n    end\n\n    # Gets the components that have been added\n    # @return [Array\u003cReactionComponent\u003e]\n    def added_components\n        components.select { |c| c.added? }\n    end\nend\n\n# Models a component of a biochemical reaction\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass ReactionComponent\n\n    include Units\n\n    attr_reader :input_name, :qty, :units, :sample, :item\n    attr_accessor :added\n\n    # Instantiates the class\n    #\n    # @param input_name [String] the name of the component\n    # @param qty [Numeric] the quantity of this component to be added to a single reaction\n    # @param units [String] the units of `qty`\n    # @param sample_name [String] the name of the Aquarium Sample to be used for this component\n    # @param object_name [String] the ObjectType (Container) that this component should be found in\n    def initialize(input_name:, qty:, units:, sample_name: nil, object_name: nil)\n        @input_name = input_name\n        @qty = qty\n        @units = units\n        @sample = sample_name ? Sample.find_by_name(sample_name) : nil\n\n        if sample \u0026\u0026 object_name\n            @item = sample.in(object_name).first\n        else\n            @item = nil\n        end\n\n        @added = false\n    end\n\n    # The input name, formatted for display in protocols\n    # @return [String]\n    def display_name\n        input_name\n    end\n\n    # Displays the volume (`qty`) with units\n    #\n    # @return [String]\n    def qty_display(round=1)\n        Units.qty_display({ qty: qty.round(round), units: units })\n    end\n\n    # Adjusts the qty by a given factor and, if needed, makes it checkable in a table\n    #\n    # @param mult [Float] the factor to multiply `qty` by\n    # @param round [FixNum] the number of places to round the result to\n    # @param checkable [Boolean] whether to make the result checkable in a table\n    # @return [Numeric, Hash]\n    def adjusted_qty(mult=1.0, round=1, checkable=true)\n        adj_qty = (qty * mult).round(round)\n        adj_qty = {content: adj_qty, check: true} if checkable\n        adj_qty\n    end\n\n    # provides the `qty` for display in a table, and markes it as `added`\n    #\n    # @param (see #adjusted_qty)\n    # @return (see #adjusted_qty)\n    def add_in_table(mult=1.0, round=1, checkable=true)\n        @added = true\n        adjusted_qty(mult, round, checkable)\n    end\n\n    # Checks if `self` has been added\n    # @return [Boolean]\n    def added?\n        added\n    end\nend"}},{"library":{"name":"PCRProgram","category":"PCR Libs","code_source":"needs \"Standard Libs/Units\"\nneeds \"Standard Libs/CommonInputOutputNames\"\n\nclass PCRProgram\n\n    include CommonInputOutputNames, Units\n\n    FINAL_STEP = \"12C (in final step of program)\"\n\n    PROGRAMS = {\n        \"qPCR1\" =\u003e {\n            name: \"NGS_qPCR1.prcl\", volume: 32, plate: \"NGS_qPCR1.pltd\",\n            steps: {\n                step1: {temp: {qty: 95, units: DEGREES_C}, time: {qty:  3, units: MINUTES}},\n                step2: {temp: {qty: 98, units: DEGREES_C}, time: {qty: 15, units: SECONDS}},\n                step3: {temp: {qty: 62, units: DEGREES_C}, time: {qty: 30, units: SECONDS}},\n                step4: {temp: {qty: 72, units: DEGREES_C}, time: {qty: 30, units: SECONDS}},\n                step5: {goto: 2, times: 34},\n                # step6: {temp: {qty: 72, units: DEGREES_C}, time: {qty:  5, units: MINUTES}},\n                step6: {temp: {qty: 12, units: DEGREES_C}, time: {qty: \"forever\", units: \"\"}}\n            }\n        },\n\n        \"qPCR2\" =\u003e {\n            name: \"NGS_qPCR2\", volume: 50, plate: \"NGS_qPCR1.pltd\",\n            steps: {\n                step1: {temp: {qty: 98, units: DEGREES_C}, time: {qty:  3, units: MINUTES}},\n                step2: {temp: {qty: 98, units: DEGREES_C}, time: {qty: 15, units: SECONDS}},\n                step3: {temp: {qty: 64, units: DEGREES_C}, time: {qty: 30, units: SECONDS}},\n                step4: {temp: {qty: 72, units: DEGREES_C}, time: {qty: 30, units: SECONDS}},\n                step5: {goto: 2, times: 29},\n                step6: {temp: {qty: 72, units: DEGREES_C}, time: {qty:  5, units: MINUTES}},\n                step7: {temp: {qty: 12, units: DEGREES_C}, time: {qty: \"forever\", units: \"\"}}\n            }\n        },\n\n        \"lib_qPCR1\" =\u003e {\n            name: \"LIB_qPCR1.prcl\", volume: 25, plate: \"LIB_qPCR.pltd\",\n            steps: {\n                step1: {temp: {qty: 95, units: DEGREES_C}, time: {qty:  3, units: MINUTES}},\n                step2: {temp: {qty: 98, units: DEGREES_C}, time: {qty: 15, units: SECONDS}},\n                step3: {temp: {qty: 65, units: DEGREES_C}, time: {qty: 30, units: SECONDS}},\n                step4: {temp: {qty: 72, units: DEGREES_C}, time: {qty: 30, units: SECONDS}},\n                step5: {goto: 2, times: 34},\n                step6: {temp: {qty: 72, units: DEGREES_C}, time: {qty:  5, units: MINUTES}},\n                step7: {temp: {qty: 12, units: DEGREES_C}, time: {qty: \"forever\", units: \"\"}}\n            }\n        },\n\n        \"lib_qPCR2\" =\u003e {\n            name: \"LIB_qPCR2.prcl\", volume: 50, plate: \"LIB_qPCR.pltd\",\n            steps: {\n                step1: {temp: {qty: 95, units: DEGREES_C}, time: {qty:  3, units: MINUTES}},\n                step2: {temp: {qty: 98, units: DEGREES_C}, time: {qty: 15, units: SECONDS}},\n                step3: {temp: {qty: 65, units: DEGREES_C}, time: {qty: 30, units: SECONDS}},\n                step4: {temp: {qty: 72, units: DEGREES_C}, time: {qty: 30, units: SECONDS}},\n                step5: {goto: 2, times: 34},\n                step6: {temp: {qty: 72, units: DEGREES_C}, time: {qty:  5, units: MINUTES}},\n                step7: {temp: {qty: 12, units: DEGREES_C}, time: {qty: \"forever\", units: \"\"}}\n            }\n        }\n    }\n\n    attr_reader :program_name, :name, :plate, :steps, :volume\n\n    def initialize(args={})\n        @program_name = args[:program_name]\n        program = PCRProgram::PROGRAMS[program_name]\n        @name = program[:name]\n        @plate = program[:plate]\n        @steps = {}\n        program[:steps].each { |k,v| @steps[k] = PCRStep.new(v) }\n        @volume = args[:volume] || program[:volume]\n    end\n\n    def table\n        table = []\n        steps.each do |k,v|\n            row = [\"#{k}\"]\n            if v.incubation?\n                row += [v.temperature_display, v.duration_display]\n            elsif v.goto?\n                row += [v.goto_display, v.times_display]\n            else\n                raise \"Unable to interpret #{v} as a PCRStep\"\n            end\n            table.append(row)\n        end\n        table\n    end\n\n    def final_step\n        FINAL_STEP\n    end\nend\n\nclass PCRStep\n    attr_reader :temperature, :duration, :goto, :times\n\n    def initialize(args={})\n        @temperature = args[:temp]\n        @duration = args[:time]\n        @goto = args[:goto]\n        @times = args[:times]\n    end\n\n    def incubation?\n        temperature \u0026\u0026 duration\n    end\n\n    def goto?\n        goto \u0026\u0026 times\n    end\n\n    def temperature_display\n        Units.qty_display(temperature)\n    end\n\n    def duration_display\n        Units.qty_display(duration)\n    end\n\n    def goto_display\n        \"goto step #{goto}\"\n    end\n\n    def times_display\n        \"#{times} times\"\n    end\nend"}},{"library":{"name":"CommonInputOutputNames","category":"Standard Libs","code_source":"module CommonInputOutputNames\n\n    INPUT_YEAST = 'Yeast Culture'\n    OUTPUT_YEAST = 'Yeast Culture'\n    MEDIA = 'Media'\n    DNA = 'DNA'\n    \n    INPUT_SAMPLE = 'Input Sample'\n    OUTPUT_SAMPLE = 'Output Sample'\n\n    FORWARD_PRIMER = 'Forward Primer'\n    REVERSE_PRIMER = 'Reverse Primer'\n    TEMPLATE = 'Template'\n    FRAGMENT = 'Fragment'\n    PROGRAM = 'Program'\n    PRIMER_PLATE = '96-Well Primer Aliquot Plate'\n\nend"}},{"library":{"name":"Units","category":"Standard Libs","code_source":"module Units\n    \n    EMPTY = -1\n    \n    # Volume\n    MICROLITERS = 'µl'\n    MILLILITERS = 'ml'\n    \n    # Weight\n    NANOGRAMS = 'ng'\n    MICROGRAMS = 'µg'\n    \n    # Concentration\n    PICOMOLAR = 'pM'\n    NANOMOLAR = 'nM'\n    MICROMOLAR = 'µM'\n    MILLIMOLAR = 'mM'\n    MOLAR = 'M'\n    \n    # Temperature\n    DEGREES_C = '°C'\n    \n    # Time\n    MINUTES = 'min'\n    SECONDS = 'sec'\n    HOURS ='hr'\n    # Force\n    TIMES_G = 'x g'\n    \n    # R/DNA Length\n    BASEPAIRS = 'bp'\n    KILOBASEPAIRS = 'kbp'\n    MEGABASEPAIRS = 'mbp'\n    GIGABASEPAIRS = 'gbp'\n    \n    # Voltage\n    VOLTS = 'V'\n\n    def self.qty_display(qty)\n        \"#{qty[:qty]} #{qty[:units]}\"\n    end\n    \n    def qty_display(qty)\n        \"#{qty[:qty]} #{qty[:units]}\"\n    end\n    \n    def add_qty_display(options)\n        new_items = {}\n        \n        options.each do |key, value|\n            key =~ /^(.+_)+([a-z]+)$/\n            \n            case $2\n            when 'microliters'\n                units = MICROLITERS\n            when 'milliliters'\n                units = MILLILITERS\n            when 'minutes'\n                units = MINUTES\n            else\n                next\n            end\n            \n            qty = value.to_f\n            \n            new_items[\"#{$1}qty\".to_sym] = { qty: qty, units: units }\n        end\n        \n        options.update(new_items)\n    end\n    \n    # Return the unit constant for the the unit name if there is one.\n    #\n    # @param unit_name [String] the name of the unit\n    # @returns the value of the constant with the given name\n    # @raises BadUnitNameError if the name is not the name of a defined unit\n    def self.get_unit(unit_name:)\n        self.const_get(unit_name.upcase)\n      rescue\n        raise BadUnitNameError.new(name: unit_name)\n    end\n    \n    # Exception class for bad unit name arguments to Units::get_unit.\n    #\n    # @attr_reader [String] name  the bad unit name\n    class BadUnitNameError \u003c StandardError\n        attr_reader :name\n        \n        def initialize(msg: \"Unknown unit name\", name:)\n            @name = name\n            super(msg)\n        end\n    end\n    \n    # Return a key for the measure hash defined on the given object type.\n    #\n    # The measure hash must be defined in the data proerty of the object type as JSON.\n    # For instance\n    #\n    #   { \"measure\": { \"type\": \"concentration\", \"unit\": \"micromolar\" } }\n    #\n    # The key is constructed as the type name, an underscore, and the unit name.\n    #\n    # @param object_type [ObjectType] the object type\n    # @returns the key for the measure of the the object type if there is one\n    # @raises MissingObjectTypeMeasure if the object type has no measure data_object\n    def self.get_measure_key(object_type:)\n        data_object = object_type.data_object\n        raise MissingObjectTypeMeasureError.new(name: object_type.name) if !data_object.key?(:measure)\n        \n        measure = object_type.data_object[:measure]\n        type_name = measure[:type]\n        unit_name = measure[:unit]\n        \"#{type_name}_#{self.get_unit(unit_name: unit_name)}\"\n    end\n    \n    # Exception class for an object type with out a measure hash definition.\n    #\n    # @attr_reader [String] name  the name of the object type where measure has was expected\n    class MissingObjectTypeMeasureError \u003c StandardError\n        attr_reader :name\n        \n        def initialize(msg: \"ObjectType has no measure in data object\", name:)\n            @name = name\n            super(msg)\n        end\n    end\n   \nend"}}]}